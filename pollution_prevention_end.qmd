---
title: "`r paste('Pollution Prevention Notice and open burning restrictions ended within', params$burnRestrictionArea)`"
type: "pollution_prevention"
date: "`r Sys.Date()`"
params: 
  sel_aqMet: "Sakshi Jain"
  nearestMonitor: "Whistler"
  issuedate: "2025-07-09"
  outputFormat: "markdown"
  customMessage: ""
  burnRestrictionArea: ""
ice: "End"
author: "`r params$sel_aqMet`"
customMessage: "`r params$customMessage`"
location: "`r params$nearestMonitor`"
outputFormat: "`r params$outputFormat`" 
format:
  markdown: default
  pdf:
    mainfont: "Roboto"
    date-format: long
    include-in-header: 
      - src/header.tex
    fontsize: "12pt"
    urlcolor: bcblue
---

```{=html}
<!--
Copyright 2025 Province of British Columbia

This work is licensed under the Creative Commons Attribution 4.0 International License.
To view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/.
-->
```

```{r setup, echo=FALSE, include=FALSE, warning=FALSE, message=FALSE}

knitr::opts_chunk$set(echo=FALSE,
                      message=FALSE,
                      warning=FALSE)

library(tidyverse)
library(knitr)
library(data.table)
library(shiny)
library(sf)
library(lubridate)
library(readr)
library(xtable)

source(here::here("load_metadata.r"))
source(here::here(file.path("functions", "local_tz.r")))
```

```{r table-setup, include=FALSE}
pollutants <- "PM25"
min_data_capture_pct <- 75

results <- list()

for (i in seq_along(pollutants)) {
  pollutant <- pollutants[i]
  
  # ---- Check that locations are valid for this pollutant ----
  valid_locations <- buddy_stations |> 
    filter(location %in% params$nearestMonitor) |> 
    pull(Buddy_location) |> 
    unique()
  
  if (length(valid_locations) == 0) {
    stop(sprintf("None of the specified locations are valid for %s.", pollutant))
  }
  
  # ---- Lookup table for units and averaging times ----
  lookup <- data.frame(
    units = c("μg/m^3^", "μg/m^3^", "ppb"),
    hours = c(24, 24, 8),
    row.names = c("PM25", "PM10", "O3")
  ) |> 
    mutate(avgtimelabel = sprintf("%d-hr", hours))
  
  # ---- Read in CSV from FTP ----
  columndefs <- cols_only(
    DATE_PST = col_character(),  # time zone assigned below; col_datetime does not support time zone assignment
    STATION_NAME = col_factor(),
    INSTRUMENT = col_factor(),  #is instrument necessary?
    REPORTED_VALUE = col_double(),
    PARAMETER = col_character(),
    EMS_ID = col_character()
  )
  
  dfraw <- read_csv(
    sprintf("ftp://ftp.env.gov.bc.ca/pub/outgoing/AIR/Hourly_Raw_Air_Data/Air_Quality/%s.csv", pollutant),
    col_types = columndefs
  ) |> 
    rename_all(tolower)
  
  # ---- Filter data to retain pnly stations relevant to this warning (params$nearestMonitor + neighbouring sites) ----
  df <- dfraw |> 
    mutate(date_pst = as.POSIXct(date_pst, format = "%Y-%m-%d %H:%M", tz = "Etc/GMT+8")) |> 
    filter(instrument != "") |>   #is this needed?
    filter(station_name %in% valid_locations)
  
  # ---- Get time window per location ----
  dts <- df |> 
    group_by(station_name) |> 
    summarize(max_dt = max(date_pst), .groups = "drop") |> 
    mutate(min_dt = max_dt - (3600 * (lookup[pollutant, "hours"] - 1)))
  
  df_filtered <- df |> 
    left_join(dts, by = "station_name") |> 
    filter(date_pst >= min_dt & date_pst <= max_dt) |> 
    select(-min_dt, -max_dt)
  
  # ---- Summarize concentrations ----
  integrated <- df_filtered |> 
    group_by(station_name, parameter) |> 
    summarize(
      n_hours = n(),
      n_na = sum(is.na(reported_value)),
      pct_valid = 100 * (n_hours - n_na) / n_hours,
      mean_conc = if_else(n_hours == n_na, NA_real_, mean(reported_value, na.rm = TRUE)),
      max_conc = if_else(n_hours == n_na, NA_real_, max(reported_value, na.rm = TRUE)),
      start_dt = min(date_pst),
      end_dt = max(date_pst),
      .groups = "drop"
    ) |> 
    mutate(
      mean_conc = na_if(mean_conc, pct_valid < min_data_capture_pct),
      max_conc = na_if(max_conc, pct_valid < min_data_capture_pct)
    )
  
  station_metadata_raw <- read_csv("ftp://ftp.env.gov.bc.ca/pub/outgoing/AIR/Hourly_Raw_Air_Data/Year_to_Date/bc_air_monitoring_stations.csv", show_col_types = FALSE) 
  station_metadata <- station_metadata_raw |> 
    rename_all(tolower) |> 
    select(station_name, location = city) |> 
    distinct()
  
  # Join with station info using STATION_NAME
  integrated <- integrated |> 
    left_join(station_metadata, by = "station_name")
  
  # ---- Define most recent hour of data and express as 12 hour clock and local time 
  
  # set system to local time of params$nearestMonitor
  Sys.setenv(TZ = local_tz(params$nearestMonitor))
  
  local_time <- integrated |> 
    filter(location == params$nearestMonitor) |> 
    pull(end_dt) |> 
    as.POSIXct(., tz = local_tz(params$nearestMonitor))
  
  local_hour <- format(lubridate::floor_date(local_time, "hour"), format = "%l:00 %p")
  
  # ---- Format final table ----
  formatted_table <- integrated |> 
    mutate(
      mean_conc = ifelse(is.finite(mean_conc), sprintf("%.1f", mean_conc), "NA"),
      max_conc = ifelse(is.finite(max_conc), sprintf("%.1f", max_conc), "NA")
    ) |> 
    pivot_wider(
      names_from = parameter,
      id_cols = c(station_name, location),
      values_from = c(mean_conc, max_conc)
    )
  
  # clean up names, drop station_name and sort by params$nearestMonitor then other stations alphabetically
  formatted_table <- formatted_table |> 
    rename_with(~ gsub(sprintf("_%s", pollutant), "", .x), everything()) |> 
    select(-station_name) |> 
    arrange(location != params$nearestMonitor)  # arrange rows with params$nearestMonitor first, then rest
  
  # transpose
  formatted_table <- formatted_table |> 
    pivot_longer(cols = -location, names_to = "Community", values_to = "concentration") |> 
    pivot_wider(names_from = "location", values_from = "concentration")
  
  # handle special case for O3
  if (pollutant != "O3") {formatted_table <- formatted_table |>  filter(Community != "max_conc")}
  
  # clean up labels
  final_table <- formatted_table |> 
    mutate(Community = case_when(
      Community == "mean_conc" ~ sprintf("%s average (%s)", lookup[pollutant, "avgtimelabel"], lookup[pollutant, "units"]),
      Community == "max_conc" ~ sprintf("Max. within %s (%s)", gsub("-", " ", lookup[pollutant, "avgtimelabel"]), lookup[pollutant, "units"]),
      TRUE ~ Community
    ))
  
  results[[paste0("final_table", i)]] <- final_table
}

# Expose them as final_table1, final_table2, etc.
list2env(results, envir = .GlobalEnv)
```

```{r ENVcontact, include=FALSE}
#| results: asis
#| strip.white: false

if (params$outputFormat == "markdown") sep_type <- "<br />" else sep_type <- "  \n"

# AQ met information
ENVcontact <- aq_mets |>
  filter(fullname == params$sel_aqMet) |>
  mutate(contact = paste(fullname_typeset, title, ministry, phone, sep = sep_type)) |> 
  pull(contact) 
```

```{r HAcontact, include=FALSE}
#| results: asis

if (params$outputFormat == "markdown") sep_type <- "<br />" else sep_type <- "  \n"

HAauth <- match_health_city |> 
  filter(location == params$nearestMonitor) |> 
  pull(health_city)

HAcontact <- health_contact |>
    filter(authority == HAauth) |>
    select(authority, contact) |>
    group_by(authority) |>
    summarise(html_string = paste(contact, collapse = sep_type))
```

```{r pollutant_specific_clauses, include=FALSE}
pollutant_tbl <- tribble(
  ~pollutant,~pollutantExpansion,
  "PM25","fine particulate matter")

# Pick the row for the current pollutant
pollutant_info <- pollutant_tbl |> filter(pollutant == "PM25")

# Assign values
pollutantExpansion  <- pollutant_info$pollutantExpansion

  first_paragraph <- paste0(
    "The Ministry of Environment and Parks in collaboration with the ", HAauth, 
    " has ended the Pollution Prevention Notice and open burning restrictions within ",
    params$burnRestrictionArea,
    " that were issued on ", 
    format(as.Date(params$issuedate), "%B %d, %Y"),
    "." 
  )

```

```{r additional_info, include=FALSE}

additional_info_PM25 <- paste0(
    "The provincial air quality objective for PM~2.5~ is 25 micrograms per cubic metre (μg/m^3^) averaged over 24 hours. 24-hour average PM~2.5~ concentrations are summarized below for ", params$nearestMonitor, " and nearest monitored communities at ", local_hour, " local time today:"
  )

```

```{r create-logo-list}

# Identify which set of logos to include in document header (note: BC Gov and FNHA logos are included in all cases so are not used to define logo file name)
# This list contains the full name (used for Alt Text and identification) on the left as the keys of the list and the initials (used for the logo file name) on the right as values of the list
logos_list <- list(
  "Government of British Columbia" = "BCID_V_RGB_pos",
  "First Nations Health Authority" = "FNHA",
  "Interior Health Authority" = "IH",
  "Fraser Health Authority" = "FH",
  "Vancouver Coastal Health Authority" = "VCH",
  "Vancouver Island Health Authority" = "VIH",
  "Northern Health Authority" = "NH"
)

# Logos selected by user and ordered as per logos_list
# Logos selected by user
logos_names_selected <- c("Government of British Columbia",
                          "First Nations Health Authority", 
                          HAauth)
logos_selected <- logos_list[logos_names_selected]

# Count number of logos to display
n_logos <- length(logos_selected)

logo_image_line <- c()
logos_combined <- c()

# Set logo path based on output format
if (params$outputFormat == "markdown") {
  logo_path <- " logo](//assets/logo_"

  # Build a vector of quarto lines to insert image for each logo
  # It is more efficient to use `sapply` but this might be more readable

  # Add each logo's insert line to the vector
  for (logo_name in names(logos_selected)) {
    logo_image_line <- c(logo_image_line,
                         paste0("![", logo_name, logo_path, logos_selected[[logo_name]], ".png)\\"))
  }}

if (params$outputFormat == "pdf") {
  
  logo_path <- "https://github.com/bcgov/aqwarnings/blob/main/frontend/assets/logo_"
  logo_urls <- c() #start with empty vector
  
  # create vector of urls
  for (logo_name in names(logos_selected)) {
    logo_urls <- c(
      logo_urls, 
      paste0(logo_path,
             logos_selected[[logo_name]],
             ".png?raw=true"
             )
    )
  }

# format logos
logos <- magick::image_read(logo_urls) |> 
  magick::image_trim() |> # remove all white space
  magick::image_border(color = "none", geometry = "100x25") |> # add uniform white space to top and right side of each image
  magick::image_scale("x200") # scale

# Combine logos into single image and scale
logos_combined <- magick::image_append(logos) |> 
  magick::image_write(path = "logo.png")
}
```

```{r create-pdf-filepath}
### TEMPORARY - until SDM signature is sorted -- also remove lines 444-450, 471

# create file path for PDF output

      # Set output file name
      output_file_name <- sprintf("%s_%s", "end", "pollution_prevention_notice") 
      mandatory_text <- NULL
        
      pdf_file_name <- paste0(Sys.Date(), "_", output_file_name, ".pdf")
      
```

<!-- Logo header, the layout-col should be set based on number of logos including FHNA and BCGov -->
<!-- the trailing slash means the text in square brackets is alt text -->

[`r paste("::: {layout-ncol=", n_logos," layout-valign=\"bottom\"}")`]{.content-visible when-format="markdown"}

```{r print-logos}
#| results: asis

# `cat` is used to avoid extra processing
# `sep` argument adds the line break and then a new line as required
if (params$outputFormat == "markdown") cat(logo_image_line, sep="\n\n") 
```

[`r paste(":::")`]{.content-visible when-format="markdown"}

`r first_paragraph`

`r params$customMessage`

## More information

::: {.content-visible when-format="markdown"}
{{< accordion_start title="Current conditions" initiallyOpen="true" >}}
:::

::: {.content-visible when-format="pdf"}
### Current conditions
:::

```{r final-table, results='asis', echo=FALSE}

# Single pollutant: PM25
if (length(pollutants) == 1 && pollutants == "PM25") {
  cat(additional_info_PM25, "\n\n")
  print(knitr::kable(final_table, row.names = FALSE))
}

```

Visit the provincial [air quality data webpage](https://www2.gov.bc.ca/gov/content/environment/air-land-water/air/air-quality) for real-time observations.

::: {.content-visible when-format="markdown"}
{{< accordion_end >}}
:::

## Contact

::: {.content-visible when-format="pdf"}
### Media questions regarding this Pollution Prevention Notice

::: {.content-visible when-format="markdown"}
**Media questions regarding this Pollution Prevention Notice:**
{{< card_start width="wide" >}}
:::

`r ENVcontact` 

::: {.content-visible when-format="markdown"}
{{< card_end >}}
:::

::: {.content-visible when-format="pdf"}
### Media questions regarding health implications related to degraded air quality
:::

::: {.content-visible when-format="markdown"}
**Media questions regarding health implications when air quality is degraded:**
{{< card_start  width="wide" >}}
:::

`r paste(HAcontact$html_string, collapse = "\n\n")`

::: {.content-visible when-format="markdown"}
{{< card_end >}}
:::
